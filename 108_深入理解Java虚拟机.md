
> Book : 《深入理解Java虚拟机：JVM高级特性与最佳实践》 第2版
>
> 机械工业出版社、周志明、2013年05月01日
> 
> 多看

### 7.4.1 类与类加载器

> 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

> 比较两个类是否“相等”，只有在这个两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

### 7.4.2 双亲委派模型

```
        Bootstrap ClassLoader
                ^
                |
        Extension ClassLoader
                ^
                |
        Application ClassLoader
        /               \
User ClassLoader    User ClassLoader
```

> 双亲委派模型的工作过程是： 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

> 使用'双亲委派模型'来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。

> 例如类 `java.lang.Object` ，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。

### 7.4.3 破坏双亲委派模型

- 线程上下文类加载器（Thread Context ClassLoader）
- Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI, JDBC, JCE, JACB, JBI
- 热替换、热部署…… OSGI









